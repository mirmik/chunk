# CHUNK_ru.ROBOTS.md

Этот документ предназначен для **языковых моделей**.
Твоя задача — **генерировать CHUNK-патчи строго в описанном формате**, без фантазий и самодеятельности.

---

## 1. Жёсткие правила формата (обязательно прочитай)

1. **Только один YAML-документ.**
   В ответе не должно быть ничего, кроме одного YAML-блока CHUNK. Никакого текста до или после.

2. **Формат — упрощённый YAML.**

   * Используй **пробелы** для отступов (не табы).
   * Рекомендуемый отступ — **2 пробела**.
   * Ключи и значения — обычный YAML 1.2.

3. **Формат комментариев.**.
   Комментарии к патчу в целом и отдельным операциям выполняй с помощью специальных полей, `description` для патча в целом и `comment` для отдельной операции. YAML-комментарии допускаются, но они не заменяют эти поля.

4. **Только описанные поля.**

   * Нельзя придумывать свои поля.
   * Нельзя менять имена полей.
   * Нельзя добавлять лишние поля «для красоты».

5. **Только известные команды.**
   Значение поля `op` **обязательно** должно быть одной из известных команд (см. раздел 2).
   Никаких новых или «похожих» названий.

6. **Многострочные строки (`payload`, большие фрагменты кода).**

   * Для многострочного текста **всегда** используй YAML-литерал `|`.
   * Содержимое блока `|` должно быть с отступом минимум 2 пробела относительно ключа.
   * Пример:

     ```yaml
     payload: |
       первая строка
       вторая строка
     ```

7. **Кодировка.**
   Считается, что всё в UTF-8. Символы юникода допустимы.

8. **Относительные пути файлов.**

   * Поле `path` всегда задаёт **относительный путь от корня репозитория**.
   * Директория `.scatwrap/` не является частью пути.
   * Примеры:

     * правильно: `src/main.cpp`
     * неправильно: `.scatwrap/src/main.cpp`

9. **Структура верхнего уровня всегда одна и та же:**

   ```yaml
   description: "краткое описание патча на человеческом языке"
   language: "ru"
   operations:
     - op: ...
       ...
     - op: ...
       ...
   ```

10. **Учитывай возможность повторов маркеров**
   Маркер в тексте ищется начиная от начала файла к концу. При выборе маркера следует проверить, что такая последавательность не встречается в файле выше.

---

## 2. Полный список команд

Команды бывают трёх типов: операции с файлами, текстовые операции и языковые (структурные) операции для кода.

### 2.1. Операции с файлами

* `create_file` — создать новый файл с указанным содержимым.
* `delete_file` — удалить существующий файл.

### 2.2. Текстовые операции

Работают с текстом файла как с последовательностью строк.

* `append_text` — дописать текст **в конец файла**.
* `prepend_text` — дописать текст **в начало файла**.
* `insert_before_text` — вставить текст **перед найденным маркером**.
* `insert_after_text` — вставить текст **после найденного маркера**.
* `replace_text` — найти маркер и **заменить его на указанный текст**.
* `delete_text` — найти маркер и **удалить его**.

### 2.3. Языковые операции (структурное API для кода)

Используются для работы с сущностями языков C++ и Python.
Применяй их **вместо `replace_text`**, когда нужно менять классы или методы.

* `replace_cpp_class` — заменить определение класса в C++-файле.
* `replace_cpp_method` — заменить определение метода (функции-члена) в C++-классе.
* `replace_cpp_function` — заменить определение свободной функции в C++-файле.
* `replace_py_class` — заменить определение класса в Python-файле.
* `replace_py_method` — заменить определение метода в Python-классе.
* `replace_c_style_block` — заменить C-подобный блок кода по шапке (от строки с сигнатурой до закрывающей фигурной скобки).

**Важно:**
Не придумывай новых команд. Используй только перечисленные выше значения `op`.

---

## 3. Структура документа CHUNK

### 3.1. Поля верхнего уровня

```yaml
description: "Краткое описание, что делает патч"
language: "ru"
operations:
  - op: ...
    ...
  - op: ...
    ...
```

* `description` — произвольное краткое описание патча на естественном языке.
* `language` — язык описания/комментариев (`"ru"` или `"en"` и так далее).
* `operations` — список операций. Каждая операция — отдельный YAML-объект (элемент списка).

### 3.2. Общие правила для операций

Каждая операция в `operations` имеет вид:

```yaml
- op: <имя-команды>
  comment: "Краткое описание, что и зачем изменяет комманда"
  path: <путь/к/файлу>
  ...другие поля команды...
```

Общие поля:

* `op` — имя команды из списка в разделе 2.
* `path` — путь к файлу относительно корня репозитория.

**Нельзя**:

* пропускать обязательные для команды поля;
* добавлять произвольные поля, не описанные для соответствующей команды.

---

## 4. Подробности по командам и примеры

Ниже — формат аргументов для каждой команды и пример минимально корректного использования.

### 4.1. Операции с файлами

#### 4.1.1. `create_file`

Создать новый файл с указанным содержимым.
Если файл уже существует — поведение определяется реализацией (обычно ошибка).

**Поля:**

* `op: "create_file"`
* `path` — путь к создаваемому файлу.
* `payload` — полный текст файла.

**Пример:**

```yaml
- op: create_file
  path: src/new_module.cpp
  payload: |
    #include "new_module.h"

    int add(int a, int b) {
        return a + b;
    }
```

---

#### 4.1.2. `delete_file`

Удалить существующий файл.

**Поля:**

* `op: "delete_file"`
* `path` — путь к файлу, который нужно удалить.

**Пример:**

```yaml
- op: delete_file
  path: src/obsolete.cpp
```

---

### 4.2. Текстовые операции

Во всех текстовых командах используется строка-маркер, по которой находится место изменения.
Модель должна подбирать маркер так, чтобы он **однозначно соответствовал нужному фрагменту**.

#### 4.2.1. `append_text`

Добавить текст в конец файла.

**Поля:**

* `op: "append_text"`
* `path` — путь к файлу.
* `payload` — текст, который нужно дописать в конец (с переводами строк, если нужно).

**Пример:**

```yaml
- op: append_text
  path: README.md
  payload: |
    ## License

    MIT
```

---

#### 4.2.2. `prepend_text`

Добавить текст в начало файла.

**Поля:**

* `op: "prepend_text"`
* `path`
* `payload`

**Пример:**

```yaml
- op: prepend_text
  path: src/main.cpp
  payload: |
    // This file is generated by CHUNK
```

---

#### 4.2.3. `insert_before_text`

Вставить текст **перед** найденным маркером.

**Поля:**

* `op: "insert_before_text"`
* `path`
* `marker` — фрагмент текста, который нужно найти в файле.
* `payload` — текст, который нужно вставить **перед** маркером.

**Пример:**

```yaml
- op: insert_before_text
  path: src/main.cpp
  marker: "int main(int argc, char** argv)"
  payload: |
    // Application entry point
```

---

#### 4.2.4. `insert_after_text`

Вставить текст **после** найденного маркера.

**Поля:**

* `op: "insert_after_text"`
* `path`
* `marker`
* `payload`

**Пример:**

```yaml
- op: insert_after_text
  path: src/logger.cpp
  marker: "Logger::Logger() {"
  payload: |
        init_default_sink();
```

**Важно**
Не повторяй маркер в теле вставляемого текста, если не желаешь его продублировать:

Неправильно:
```yaml
- op: insert_after_text
  path: src/logger.cpp
  marker: "Logger::Logger() {"
  payload: |
    Logger::Logger() {
        init_default_sink();
```

Правильно:
```yaml
- op: insert_after_text
  path: src/logger.cpp
  marker: "Logger::Logger() {"
  payload: |
        init_default_sink();
```

---

#### 4.2.5. `replace_text`

Найти маркер и заменить его указанным текстом.

**Поля:**

* `op: "replace_text"`
* `path`
* `marker` — заменяемый фрагмент текста.
* `payload` — новый текст, вставляемый вместо маркера.

**Пример:**

```yaml
- op: replace_text
  path: src/config.h
  marker: "#define VERSION \"0.1.0\""
  payload: |
    #define VERSION "0.2.0"
```

---

#### 4.2.6. `delete_text`

Удалить найденный маркер.

**Поля:**

* `op: "delete_text"`
* `path`
* `marker` — текст, который нужно удалить.

**Пример:**

```yaml
- op: delete_text
  path: src/debug.cpp
  marker: "std::cout << \"DEBUG\" << std::endl;"
```

---

### 4.3. Языковые операции для C++ и Python

Эти команды работают не по «сырому тексту», а по структуре кода (классы, методы).
Используй их для безопасной замены классов/методов вместо `replace_text`.

> ⚠ Конкретный синтаксис поиска (учёт пробелов, комментариев и так далее) реализован на стороне утилиты.
> Твоя задача — корректно заполнить поля: оп, путь, имя класса/метода и новый код.

#### 4.3.1. `replace_cpp_class`

Заменить определение C++-класса целиком.

**Поля (минимально):**

* `op: "replace_cpp_class"`
* `path` — путь к C++-файлу (`.h`, `.hpp`, `.cpp` и так далее).
* `class` — имя класса, который нужно заменить.
* `payload` — новое определение класса (полный код класса).

**Пример:**

```yaml
- op: replace_cpp_class
  path: src/foo.h
  class: Foo
  payload: |
    class Foo {
    public:
        explicit Foo(int value);
        int value() const;
    private:
        int value_;
    };
```

---

#### 4.3.2. `replace_cpp_method`

Заменить определение метода C++ внутри класса.

**Поля (минимально):**

* `op: "replace_cpp_method"`
* `path` — путь к файлу, содержащему реализацию метода.
* `class` — имя класса.
* `method` — имя метода.
* `payload` — новое полное определение метода (с сигнатурой и телом).

**Пример:**

```yaml
- op: replace_cpp_method
  path: src/foo.cpp
  class: Foo
  method: value
  payload: |
    int Foo::value() const {
        return value_ * 2;
    }
```

---

#### 4.3.3. `replace_py_class`

Заменить определение Python-класса.

**Поля:**

* `op: "replace_py_class"`
* `path` — путь к `.py`-файлу.
* `class` — имя класса.
* `payload` — новое полное определение класса.

**Пример:**

```yaml
- op: replace_py_class
  path: app/models.py
  class: User
  payload: |
    class User:
        def __init__(self, name: str) -> None:
            self.name = name
```

---

#### 4.3.4. `replace_py_method`

Заменить метод внутри Python-класса.

**Поля:**

* `op: "replace_py_method"`
* `path`
* `class` — имя класса.
* `method` — имя метода.
* `payload` — новое определение метода (с `def` и телом).

**Пример:**

```yaml
- op: replace_py_method
  path: app/models.py
  class: User
  method: greet
  payload: |
    def greet(self) -> str:
        return f"Hello, {self.name}!"
```

---

#### 4.3.5. `replace_cpp_function`

Заменить определение **свободной C++ функции** (включая имя, сигнатуру и тело).

**Поля (минимально):**

* `op: "replace_cpp_function"`
* `path` — путь к C++-файлу (`.h`, `.hpp`, `.cpp` и так далее).
* `function` — имя функции (например, `foo`) **или**
* `symbol` — квалифицированное имя функции (например, `ns::foo`).
* `payload` — новое полное определение функции (с сигнатурой и телом).

**Примеры:**

Минимальный пример по имени функции:

```yaml
- op: replace_cpp_function
  path: src/math.cpp
  function: foo
  payload: |
    int foo(int x) {
        return x * 2;
    }
```

Пример с квалифицированным именем:

```yaml
- op: replace_cpp_function
  path: src/math.cpp
  symbol: math::sum
  payload: |
    int math::sum(int a, int b) {
        return a + b;
    }
```

#### 4.3.6. `replace_c_style_block`

Заменить C-подобный блок кода (функцию, `if`-блок и т.п.), ограниченный фигурными скобками.

**Поля (минимально):**

* `op: "replace_c_style_block"`
* `path` — путь к файлу.
* `marker` — «шапка» блока от первой строки сигнатуры до строки с открывающей `{`. При поиске игнорируются комментарии и лишние пробелы так же, как в `replace_text`.
* `payload` — новый полный блок, начиная с шапки и до закрывающей `}`.

**Пример:**

```yaml
- op: replace_c_style_block
  path: src/foo.cpp
  marker: |
    void foo()
    {
  payload: |
    void bar()
    {
        // do something
    }
```

### 4.3.7. replace_py_block

Команда для Python, аналогичная `replace_c_style_block`, но вместо фигурных
скобок использует двоеточие и отступы в стиле Python.

* `marker` должен включать строку, где находится двоеточие, открывающее блок
  (`if ...:`, `for ...:`, `while ...:`, `with ...:`, `def ...:`, `class ...:` и т.д.).
* Область замены — от начала маркера до конца блока, то есть до первой строки,
  чей отступ **не больше**, чем у строки с двоеточием. Пустые строки внутри
  блока допускаются и не обрывают его.
* Остальные поля (`payload`, `before`, `after`, `options.indent`) работают так же,
  как у `replace_c_style_block`.

Пример:

```yaml
operations:
  - path: src/main.py
    op: replace_py_block
    marker: |-
      if __name__ == "__main__":
    payload: |-
      if __name__ == "__main__":
          print("Hello from CHUNK")
```

## 5. Чего делать нельзя

1. Нельзя добавлять текст до или после YAML-документа CHUNK.
2. Нельзя придумывать свои команды (`op`) или поля.
3. Нельзя менять структуру верхнего уровня (`description`, `language`, `operations`).
4. Нельзя забывать обязательные поля для выбранной команды.
5. Запрещается переставлять слова в естественном тексте.
6. Оставлять метки вроде `::contentReference[oaicite:0]{index=0}` в теле документа.

---

## 6. Будь аккуратен
1. Обязательно проверяй корректность отступов.
2. При редактировании документации пиши маркеры абсолютно точно, в соответствии с исходным текстом. Переставлять слова в маркере запрещается.
3. Следу порядку комментирования. Обязательно используй поля `description` и `comment`. Заполняй `comment` для каждой операции. 

---


## 7. Рекомендуемая базовая форма ответа

Когда от тебя требуется сгенерировать патч CHUNK, отвечай **ровно в таком виде** (пример skeleton):

```yaml
description: "Кратко, что делает патч"
language: "ru"
operations:
  - op: ...
    path: ...
    ...
  - op: ...
    path: ...
    ...
```
---

