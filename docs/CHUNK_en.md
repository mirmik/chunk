# CHUNK patch format

The CHUNK format is designed to

* be simple enough to be read by a human and generated by a neural network;
* and strict enough to safely modify source code.

This file describes the **file format and command semantics**.  
CHUNK uses a simplified YAML (YAML Ain't Markup Language) syntax because neural networks tend to generate YAML documents more reliably than unified diffs.

---

## 1. File structure

The root of a YAML document is an **object** with a required `operations` field:

```yaml
operations:
  - path: src/foo.cpp
    op: replace_text
    ...
  - path: src/foo.py
    op: replace_text
    ...
```

It is also optional, but highly recommended, to add a human description `description` and a programming language `language` (currently `c++` and `python` are supported):

```yaml
description: "Short description of the patch"
language: c++
operations:
  - path: ...
    op: ...
    ...
```

* `operations` — array of operations.
* each element of the array is a separate operation; operations are applied **in the order** they appear in the document.

Additionally, each operation can have an optional `comment` field with any description:

```yaml
operations:
  - path: src/foo.cpp
    op: replace_text
    comment: "Local note for this operation"
    ...
```

The `comment` field does not affect how the patch is applied and is only for explanations.

---

## 2. Markers, whitespace, comment ignoring

Text and block commands use the following fields:

* `marker` — main fragment to search for;
* `before` — context before the marker (optional);
* `after` — context after the marker (optional).

The last two are optional. They can be used to disambiguate a marker when there are duplicates in the file.  
All three fields are multiline YAML scalars (`|` / `|-`).

### 2.1. Marker search

When searching for a marker we **ignore differences in indentation, trailing spaces, and the number of empty lines**, so that patches do not break due to formatting differences between various IDEs (integrated development environments) and web viewers, including those used by neural networks when reading code from links.

We also **ignore comments in the programming language specified by `language`** (`c++` or `python`). This is done because a neural network often:

* either “swallows” comments when rewriting the marker text — and then they need to be ignored;
* or, on the contrary, includes a comment inside the marker — and that should also be handled correctly.

Marker normalization rules:

* spaces and tab characters at the beginning and end of each line are removed;
* empty lines are ignored;
* the resulting range `[begin, end]` is computed in terms of actual file lines, including removed empty ones.

From CHUNK’s point of view, the following markers are identical:

```
         A

B
```

and

```
A
            B
```

because both normalize to:

```
A
B
```

---

## 3. `payload` indentation

By default, the indentation of the inserted text is aligned to the indentation of the beginning of the marker, but this behavior can be changed:

```yaml
operations:
  - path: src/foo.cpp
    op: replace_text
    marker: |-
      int value() const;
    payload: |-
      int value() const noexcept;
    options:
      indent: <mode>
```

Modes:

* `from-marker` / `marker` / `auto` — align `payload` to the marker’s indentation  
  (default mode if `options.indent` is not specified);
* `none` / `as-is` — keep `payload` indentation “as is” according to YAML rules.

Base indentation is taken from:

* for text commands — the first line of the marker range;
* for language commands (`replace_c_style_block`, `replace_py_block`) — the line with the block “header” (function signature, `if ...`, `for ...`, `def ...`, `class ...` and so on).

Indentation is added only to **non-empty** lines of `payload`.

---

## 4. File commands

### 4.1. `create_file`

Create or overwrite a file:

```yaml
operations:
  - path: src/hello.cpp
    op: create_file
    payload: |-
      #include <iostream>

      int main() {
          std::cout << "Hello\n";
          return 0;
      }
```

* `path` — target file.
* `payload` — file contents (can be empty → empty file).

### 4.2. `delete_file`

Delete a file:

```yaml
operations:
  - path: src/obsolete.cpp
    op: delete_file
```

---

## 5. Text commands

These commands operate on arbitrary text via a marker.

Required fields:

* `path`
* `op: insert_after_text | insert_before_text | replace_text | delete_text | prepend_text | append_text`
* `marker` — required for marker-based operations (`insert_after_text`, `insert_before_text`, `replace_text`, `delete_text`).

For `prepend_text` and `append_text` the `marker` field is not used: they simply insert `payload` at the beginning or at the end of the file.

Additional fields:

* `before`, `after` — optional context showing what surrounds the marker;
* `payload` — required for all except `delete_text`;
* `comment` — human-readable note for the operation;
* `options.indent` — optional indentation mode (see section 3).

### 5.1. `replace_text`

Replace a fragment by marker:

```yaml
operations:
  - path: src/foo.cpp
    op: replace_text
    marker: |-
      int value() const;
    payload: |-
      int value() const noexcept;
```

### 5.2. `insert_after_text`

Insert text immediately **after** the marker:

```yaml
operations:
  - path: src/foo.cpp
    op: insert_after_text
    marker: |-
      void Foo::init()
      {
          do_stuff();
      }
    payload: |-
      void Foo::log_state() const
      {
          // ...
      }
```

### 5.3. `insert_before_text`

Insert text **before** the marker:

```yaml
operations:
  - path: src/foo.cpp
    op: insert_before_text
    marker: |-
      public:
          void run();
    payload: |-
      public:
          void debug_run();
```

### 5.4. `delete_text`

Delete a fragment by marker:

```yaml
operations:
  - path: src/foo.cpp
    op: delete_text
    marker: |-
      #include "debug.h"
```

### 5.5. `prepend_text`

Insert text at the beginning of the file without a marker:

```yaml
operations:
  - path: src/foo.cpp
    op: prepend_text
    payload: |-
      // This block will be inserted at the very beginning of the file.
      // ...
```

### 5.6. `append_text`

Insert text at the end of the file without a marker:

```yaml
operations:
  - path: src/foo.cpp
    op: append_text
    payload: |-
      // This block will be added to the very end of the file.
      // ...
```

---

## 6. Commands for C-style and Python blocks

These commands operate not on arbitrary text, but on **logical code blocks** (functions, methods, `if` or `for` blocks, and so on).

Supported commands:

* `replace_c_style_block`
* `replace_py_block`

Common fields:

* `path`
* `op`
* `marker` — block “header” (see below);
* `payload` — new code for the whole block;
* `before`, `after` — optional context around the marker;
* `comment` — human-readable note for the operation;
* `options.indent` — indentation mode (same as in section 3).

### 6.1. C-style code: `replace_c_style_block`

Replaces a C-style code block (function, method, `if` block and so on) delimited by braces.

* `marker` must include the block header from the first line of the signature down to the line with the opening `{`.  
  During search, comments and extra spaces are ignored just like in `replace_text`.
* Replacement range spans from the beginning of the marker to the corresponding closing `}`.

Example:

```yaml
operations:
  - path: src/foo.cpp
    op: replace_c_style_block
    comment: "Update Foo::value implementation in C++"
    marker: |-
      int Foo::value() const
      {
    payload: |-
      int Foo::value() const
      {
          // new logic
          return 42;
      }
```

### 6.2. Python-style code: `replace_py_block`

Command for Python blocks, analogous to `replace_c_style_block`, but using a colon and indentation instead of braces.

* `marker` must include the line with the colon that opens the block (`if ...:`, `for ...:`, `while ...:`, `with ...:`, `def ...:`, `class ...:` and so on).
* Replacement range spans from the beginning of the marker to the end of the block, that is, up to the first line whose indentation is **not greater** than the indentation of the header line. Empty lines inside the block are allowed and do not terminate it.
* Other fields (`payload`, `before`, `after`, `options.indent`) behave the same as for `replace_c_style_block`.

Example:

```yaml
operations:
  - path: src/foo.py
    op: replace_py_block
    comment: "Update Foo.run implementation in Python"
    marker: |-
      def run(self):
    payload: |-
      def run(self):
          print("value:", self.value)
          return self.value
```

---

## 7. Example of a full patch

```yaml
description: "Update value implementation in C++ and Python"
language: c++

operations:
  - path: src/foo.cpp
    op: replace_c_style_block
    comment: "Update Foo::value implementation in C++"
    marker: |-
      int Foo::value() const
      {
    payload: |-
      int Foo::value() const
      {
          return 42;
      }

  - path: src/foo.py
    op: replace_py_block
    comment: "Update Foo.run implementation in Python"
    marker: |-
      def run(self):
    payload: |-
      def run(self):
          print("value:", self.value)
          return self.value
```
