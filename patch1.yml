description: "Сделать verbose-диагностику маркера более человекочитаемой: показать контекст маркера и файла вокруг рассинхрона"
language: "ru"
operations:
  - op: replace-cpp-method
    path: src/commands/command_base.hpp
    class: MarkerTextCommand
    method: append_debug_info
    payload: |
      void append_debug_info(std::ostream &os) const override
      {
          if (!marker_.empty())
          {
              os << "\nsection marker preview:\n";
              std::size_t max_preview_lines = 3;
              for (std::size_t i = 0;
                   i < marker_.size() && i < max_preview_lines;
                   ++i)
              {
                  os << marker_[i] << "\n";
              }
          }

          if (!chunk_verbose_logging_enabled())
              return;
          if (debug_file_text_.empty() || marker_.empty())
              return;

          std::string marker_text = join_lines(marker_);
          if (marker_text.empty())
              return;

          const std::string &file_text = debug_file_text_;
          std::size_t best_pos = std::string::npos;
          std::size_t best_len = 0;
          if (!file_text.empty())
          {
              for (std::size_t i = 0; i < file_text.size(); ++i)
              {
                  std::size_t j = 0;
                  while (i + j < file_text.size() && j < marker_text.size() &&
                         file_text[i + j] == marker_text[j])
                  {
                      ++j;
                  }
                  if (j > best_len)
                  {
                      best_len = j;
                      best_pos = i;
                      if (best_len == marker_text.size())
                          break;
                  }
              }
          }
          if (best_pos == std::string::npos)
              return;

          std::size_t mismatch_file_pos = best_pos + best_len;
          std::size_t mismatch_marker_pos = best_len;

          os << "\nverbose marker diagnostics:\n";
          os << "  best marker prefix match length: " << best_len
             << " of " << marker_text.size() << " bytes\n";

          if (best_len == marker_text.size())
          {
              os << "  note: full marker matched; most likely error is in marker search logic\n";
              return;
          }

          std::size_t line = 1;
          std::size_t column = 1;
          for (std::size_t i = 0; i < mismatch_file_pos && i < file_text.size(); ++i)
          {
              if (file_text[i] == '\n')
              {
                  ++line;
                  column = 1;
              }
              else
              {
                  ++column;
              }
          }
          os << "  file position: offset " << mismatch_file_pos
             << ", line " << line << ", column " << column << "\n";

          auto hex_of = [](unsigned char c) -> std::string {
              char buf[3];
              unsigned char hi = static_cast<unsigned char>((c >> 4) & 0x0F);
              unsigned char lo = static_cast<unsigned char>(c & 0x0F);
              buf[0] = static_cast<char>(hi < 10 ? ('0' + hi) : ('A' + (hi - 10)));
              buf[1] = static_cast<char>(lo < 10 ? ('0' + lo) : ('A' + (lo - 10)));
              buf[2] = '\0';
              return std::string(buf, 2);
          };

          if (mismatch_file_pos < file_text.size())
          {
              unsigned char fc =
                  static_cast<unsigned char>(file_text[mismatch_file_pos]);
              os << "  file mismatch byte (hex): 0x" << hex_of(fc) << "\n";
          }
          else
          {
              os << "  note: mismatch is at end of file\n";
          }

          if (mismatch_marker_pos < marker_text.size())
          {
              unsigned char mc =
                  static_cast<unsigned char>(marker_text[mismatch_marker_pos]);
              os << "  marker byte (hex):        0x" << hex_of(mc) << "\n";
          }

          const std::size_t max_tail = 32;
          if (mismatch_file_pos < file_text.size())
          {
              std::size_t available = file_text.size() - mismatch_file_pos;
              std::size_t len = available < max_tail ? available : max_tail;
              os << "  file tail (hex):";
              for (std::size_t i = 0; i < len; ++i)
              {
                  unsigned char c =
                      static_cast<unsigned char>(file_text[mismatch_file_pos + i]);
                  os << " " << hex_of(c);
              }
              os << "\n";
          }

          auto print_context = [&os](const char *label,
                                     const std::string &text,
                                     std::size_t pos) {
              if (text.empty() || pos >= text.size())
                  return;
              std::size_t start = pos;
              while (start > 0 && text[start - 1] != '\n' && text[start - 1] != '\r')
                  --start;
              std::size_t end = pos;
              while (end < text.size() && text[end] != '\n' && text[end] != '\r')
                  ++end;
              std::string line_str = text.substr(start, end - start);
              os << "  " << label << ":\n";
              os << "    " << line_str << "\n";
              os << "    ";
              std::size_t caret_pos = pos - start;
              for (std::size_t i = 0; i < caret_pos && i < line_str.size(); ++i)
              {
                  char c = line_str[i];
                  os << (c == '\t' ? '\t' : ' ');
              }
              os << "^\n";
          };

          print_context("marker context around mismatch", marker_text, mismatch_marker_pos);
          print_context("file context around mismatch", file_text, mismatch_file_pos);
      }
