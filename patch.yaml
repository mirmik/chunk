description: >
  Add YAML support for symbol operations (replace_cpp_class/method,
  replace_py_class/method) in parse_yaml_patch_text.
operations:
  - path: src/apply_chunk_v2.cpp
    op: replace_text
    marker: |
      std::string op_name = it_op->second.as_string();
      
      if (op_name == "create_file")
          s.command = "create-file";
      else if (op_name == "delete_file")
          s.command = "delete-file";
      else if (op_name == "insert_after_text")
          s.command = "insert-after-text";
      else if (op_name == "insert_before_text")
          s.command = "insert-before-text";
      else if (op_name == "replace_text")
          s.command = "replace-text";
      else if (op_name == "delete_text")
          s.command = "delete-text";
      else
          throw std::runtime_error("YAML patch: unknown op: " + op_name);
    payload: |
      std::string op_name = it_op->second.as_string();
      if (op_name == "create_file")
          s.command = "create-file";
      else if (op_name == "delete_file")
          s.command = "delete-file";
      else if (op_name == "insert_after_text")
          s.command = "insert-after-text";
      else if (op_name == "insert_before_text")
          s.command = "insert-before-text";
      else if (op_name == "replace_text")
          s.command = "replace-text";
      else if (op_name == "delete_text")
          s.command = "delete-text";
      else if (op_name == "replace_cpp_class")
          s.command = "replace-cpp-class";
      else if (op_name == "replace_cpp_method")
          s.command = "replace-cpp-method";
      else if (op_name == "replace_py_class")
          s.command = "replace-py-class";
      else if (op_name == "replace_py_method")
          s.command = "replace-py-method";
      else
          throw std::runtime_error("YAML patch: unknown op: " + op_name);

  - path: src/apply_chunk_v2.cpp
    op: replace_text
    marker: |
      std::string marker_text  = get_scalar("marker");
      std::string before_text  = get_scalar("before");
      std::string after_text   = get_scalar("after");
      std::string payload_text = get_scalar("payload");
      // Опции (используем только indent)
      auto it_opts = m.find("options");
      if (it_opts != m.end() && !it_opts->second.is_nil())
      {
          const auto &opts = it_opts->second.as_dict();
          auto it_ind = opts.find("indent");
          if (it_ind != opts.end())
          {
              std::string mode = it_ind->second.as_string();
              // явное выключение авто-идентации
              if (mode == "none" || mode == "as-is")
              {
                  s.indent_from_marker = false;
              }
              // явно включить (на случай если кто-то всё ещё пишет from-marker)
              else if (mode == "from-marker" || mode == "marker" || mode == "auto")
              {
                  s.indent_from_marker = true;
              }
              else
              {
                  throw std::runtime_error(
                      "YAML patch: unknown indent mode: " + mode);
              }
          }
      }
      if (s.command == "create-file")
      {
          if (!payload_text.empty())
              s.payload = split_scalar_lines(payload_text);
      }
      else if (s.command == "delete-file")
      {
          // Ничего больше не нужно.
      }
      else if (is_text_command(s.command))
      {
          if (marker_text.empty())
              throw std::runtime_error(
                  "YAML patch: text op '" + op_name +
                  "' for file '" + s.filepath + "' requires 'marker'");
          s.marker = split_scalar_lines(marker_text);

          if (!before_text.empty())
              s.before = split_scalar_lines(before_text);
          if (!after_text.empty())
              s.after = split_scalar_lines(after_text);
          if (s.command != "delete-text")
          {
              if (!payload_text.empty())
                  s.payload = split_scalar_lines(payload_text);
          }
      }
      else
      {
          // сюда попадать не должны (create/delete уже обработаны)
      }
    payload: |
      std::string marker_text  = get_scalar("marker");
      std::string before_text  = get_scalar("before");
      std::string after_text   = get_scalar("after");
      std::string payload_text = get_scalar("payload");
      std::string class_text   = get_scalar("class");
      std::string method_text  = get_scalar("method");
      std::string symbol_text  = get_scalar("symbol");
      // Опции (используем только indent)
      auto it_opts = m.find("options");
      if (it_opts != m.end() && !it_opts->second.is_nil())
      {
          const auto &opts = it_opts->second.as_dict();
          auto it_ind = opts.find("indent");
          if (it_ind != opts.end())
          {
              std::string mode = it_ind->second.as_string();
              // явное выключение авто-идентации
              if (mode == "none" || mode == "as-is")
              {
                  s.indent_from_marker = false;
              }
              // явно включить (на случай если кто-то всё ещё пишет from-marker)
              else if (mode == "from-marker" || mode == "marker" || mode == "auto")
              {
                  s.indent_from_marker = true;
              }
              else
              {
                  throw std::runtime_error(
                      "YAML patch: unknown indent mode: " + mode);
              }
          }
      }
      if (s.command == "create-file")
      {
          if (!payload_text.empty())
              s.payload = split_scalar_lines(payload_text);
      }
      else if (s.command == "delete-file")
      {
          // Ничего больше не нужно.
      }
      else if (is_text_command(s.command))
      {
          if (marker_text.empty())
              throw std::runtime_error(
                  "YAML patch: text op '" + op_name +
                  "' for file '" + s.filepath + "' requires 'marker'");
          s.marker = split_scalar_lines(marker_text);

          if (!before_text.empty())
              s.before = split_scalar_lines(before_text);
          if (!after_text.empty())
              s.after = split_scalar_lines(after_text);
          if (s.command != "delete-text")
          {
              if (!payload_text.empty())
                  s.payload = split_scalar_lines(payload_text);
          }
      }
      else if (is_symbol_command(s.command))
      {
          if (payload_text.empty())
              throw std::runtime_error(
                  "YAML patch: symbol op '" + op_name +
                  "' for file '" + s.filepath + "' requires 'payload'");
          s.payload = split_scalar_lines(payload_text);

          if (s.command == "replace-cpp-class" ||
              s.command == "replace-py-class")
          {
              if (class_text.empty())
                  throw std::runtime_error(
                      "YAML patch: op '" + op_name + "' requires 'class' key");
              s.arg1 = class_text;
          }
          else if (s.command == "replace-cpp-method" ||
                   s.command == "replace-py-method")
          {
              if (!class_text.empty() && !method_text.empty())
              {
                  s.arg1 = class_text;
                  s.arg2 = method_text;
              }
              else if (!symbol_text.empty())
              {
                  // для cpp ожидаем "Class::method", для python — "Class.method"
                  s.arg1 = symbol_text;
              }
              else
              {
                  throw std::runtime_error(
                      "YAML patch: op '" + op_name +
                      "' requires 'class'+'method' or 'symbol'");
              }
          }
      }
      else
      {
          // сюда попадать не должны (create/delete/symbol уже обработаны)
      }
