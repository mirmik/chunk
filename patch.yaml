description: "Two-pass marker search: first without comment ignoring, then with; plus test"
language: c++
operations:
  - path: src/text_commands.cpp
    op: replace_text
    marker: "find_marker_matches(const std::vector<std::string> &haystack,"
    payload: "find_marker_matches_ignore_comments(const std::vector<std::string> &haystack,"

  - path: src/text_commands.cpp
    op: insert_before_text
    marker: "} // namespace"
    payload: |-
      std::vector<MarkerMatch>
      find_marker_matches_no_comment_ignore(const std::vector<std::string> &haystack,
                                            const std::vector<std::string> &needle,
                                            const Section * /*section*/)
      {
          std::vector<MarkerMatch> matches;

          std::vector<std::string> pat;
          pat.reserve(needle.size());
          for (const auto &s : needle)
          {
              std::string t = trim(s);
              if (!t.empty())
                  pat.push_back(std::move(t));
          }

          if (pat.empty())
              return matches;

          std::vector<std::string> hs;
          std::vector<int>         hs_idx;
          hs.reserve(haystack.size());
          hs_idx.reserve(haystack.size());
          for (int i = 0; i < (int)haystack.size(); ++i)
          {
              std::string t = trim(haystack[i]);
              if (!t.empty())
              {
                  hs.emplace_back(std::move(t));
                  hs_idx.push_back(i);
              }
          }

          if (hs.empty() || pat.size() > hs.size())
              return matches;

          const std::size_t n = hs.size();
          const std::size_t m = pat.size();

          for (std::size_t i = 0; i + m <= n; ++i)
          {
              bool ok = true;
              for (std::size_t j = 0; j < m; ++j)
              {
                  if (hs[i + j] != pat[j])
                  {
                      ok = false;
                      break;
                  }
              }
              if (ok)
              {
                  int begin = hs_idx[i];
                  int end   = hs_idx[i + m - 1];
                  matches.push_back(MarkerMatch{begin, end});
              }
          }

          return matches;
      }

      std::vector<MarkerMatch>
      find_marker_matches(const std::vector<std::string> &haystack,
                          const std::vector<std::string> &needle,
                          const Section *section)
      {
          std::vector<MarkerMatch> matches =
              find_marker_matches_no_comment_ignore(haystack, needle, section);
          if (!matches.empty())
              return matches;

          return find_marker_matches_ignore_comments(haystack, needle, section);
      }

  - path: tests/apply_yaml.cpp
    op: insert_before_text
    marker: "// 18. YAML symbol API: replace_cpp_class"
    payload: |-
      // 18. Prefer exact match with comments before ignoring them
      // ============================================================================
      TEST_CASE("YAML patch: prefer exact C++ marker match before ignoring comments")
      {
          fs::path tmp = fs::temp_directory_path() / "yaml_cpp_prefer_exact_with_comments";
          fs::remove_all(tmp);
          fs::create_directories(tmp);
          fs::path f = tmp / "code.cpp";
          {
              std::ofstream out(f);
              out << "void foo() {\n"
                  << "    int x = 1; // foo\n"
                  << "    int y = 2;\n"
                  << "}\n"
                  << "\n"
                  << "void bar() {\n"
                  << "    int x = 1;\n"
                  << "    int y = 2;\n"
                  << "}\n";
          }
          fs::path patch = tmp / "patch.yml";
          {
              std::ofstream out(patch);
              out << "language: cpp\n";
              out << "operations:\n";
              out << "  - path: " << f.string() << "\n";
              out << "    op: replace_text\n";
              out << "    marker: |\n";
              out << "      void foo() {\n";
              out << "        int x = 1; // foo\n";
              out << "        int y = 2;\n";
              out << "      }\n";
              out << "    payload: |\n";
              out << "      void foo() {\n";
              out << "        int x = 10; // foo\n";
              out << "        int y = 20;\n";
              out << "      }\n";
          }

          CHECK(run_apply(patch) == 0);
          auto L = read_lines(f);
          REQUIRE(!L.empty());

          std::string all;
          for (auto &s : L)
              all += s + "\n";

          // foo обновился
          CHECK(all.find("int x = 10; // foo") != std::string::npos);
          CHECK(all.find("int y = 20;") != std::string::npos);

          // bar остался как был
          CHECK(all.find("void bar() {") != std::string::npos);
          CHECK(all.find("int x = 1;\n") != std::string::npos);
      }
