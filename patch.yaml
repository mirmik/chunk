language: c++
operations:
  - op: create_file
    path: src/commands/replace_py_block.hpp
    payload: |-
      #pragma once
      #include "command_base.hpp"
      #include "commands/symbol_utils.h"
      #include "commands/text_utils.h"
      #include <stdexcept>
      #include <cctype>
      
      class ReplacePyBlockCommand : public Command
      {
      public:
          ReplacePyBlockCommand()
              : Command("replace-py-block")
          {
          }
      
          void parse(const nos::trent &tr) override
          {
              using namespace command_parse;
              filepath_ = get_scalar(tr, "path");
              if (filepath_.empty())
                  throw std::runtime_error(
                      "replace-py-block: missing 'path'");
      
              indent_from_marker_ = parse_indent_from_options(tr, true);
      
              const auto &dict = tr.as_dict();
              auto it_comment = dict.find("comment");
              if (it_comment != dict.end() && !it_comment->second.is_nil())
                  comment_ = it_comment->second.as_string();
      
              std::string marker_text = get_scalar(tr, "marker");
              if (marker_text.empty())
                  throw std::runtime_error(
                      "replace-py-block: 'marker' cannot be empty");
              marker_ = split_scalar_lines(marker_text);
      
              std::string payload_text = get_scalar(tr, "payload");
              if (payload_text.empty())
                  throw std::runtime_error(
                      "replace-py-block: 'payload' is required and cannot be empty");
              payload_ = split_scalar_lines(payload_text);
      
              auto it_before = dict.find("before");
              if (it_before != dict.end() && !it_before->second.is_nil())
                  before_ = split_scalar_lines(it_before->second.as_string());
      
              auto it_after = dict.find("after");
              if (it_after != dict.end() && !it_after->second.is_nil())
                  after_ = split_scalar_lines(it_after->second.as_string());
          }
      
          void execute(std::vector<std::string> &lines) override
          {
              using namespace text_utils;
      
              if (marker_.empty())
                  throw std::runtime_error(
                      "replace-py-block: empty marker after parse");
      
              PatchLanguage lang = detect_language(language_);
              auto matches = find_marker_matches(lines, marker_, lang);
              if (matches.empty())
              {
                  throw std::runtime_error(
                      "replace-py-block: marker not found in file: " + filepath_);
              }
      
              int idx =
                  find_best_marker_match(lines, lang, before_, after_, matches);
              if (idx < 0 ||
                  idx >= static_cast<int>(matches.size()))
                  throw std::runtime_error(
                      "replace-py-block: internal error choosing marker match");
      
              const MarkerMatch &mm = matches[static_cast<std::size_t>(idx)];
      
              int header_line = -1;
              int header_col = -1;
      
              bool in_single = false;
              bool in_double = false;
              bool in_triple_single = false;
              bool in_triple_double = false;
              bool escape = false;
      
              for (int li = mm.begin; li <= mm.end; ++li)
              {
                  if (li < 0 ||
                      li >= static_cast<int>(lines.size()))
                      continue;
      
                  const std::string &ln =
                      lines[static_cast<std::size_t>(li)];
                  bool in_comment = false;
      
                  for (std::size_t col = 0; col < ln.size(); ++col)
                  {
                      char c = ln[col];
                      char next =
                          (col + 1 < ln.size()) ? ln[col + 1] : '\0';
                      char next2 =
                          (col + 2 < ln.size()) ? ln[col + 2] : '\0';
      
                      if (in_comment)
                          break;
      
                      if (in_triple_single)
                      {
                          if (c == '\'' && next == '\'' && next2 == '\'')
                          {
                              in_triple_single = false;
                              col += 2;
                          }
                          continue;
                      }
                      if (in_triple_double)
                      {
                          if (c == '"' && next == '"' && next2 == '"')
                          {
                              in_triple_double = false;
                              col += 2;
                          }
                          continue;
                      }
                      if (in_single)
                      {
                          if (escape)
                          {
                              escape = false;
                              continue;
                          }
                          if (c == '\\')
                          {
                              escape = true;
                              continue;
                          }
                          if (c == '\'')
                          {
                              in_single = false;
                          }
                          continue;
                      }
                      if (in_double)
                      {
                          if (escape)
                          {
                              escape = false;
                              continue;
                          }
                          if (c == '\\')
                          {
                              escape = true;
                              continue;
                          }
                          if (c == '"')
                          {
                              in_double = false;
                          }
                          continue;
                      }
      
                      if (c == '#')
                      {
                          in_comment = true;
                          break;
                      }
                      if (c == '\'')
                      {
                          if (next == '\'' && next2 == '\'')
                          {
                              in_triple_single = true;
                              col += 2;
                          }
                          else
                          {
                              in_single = true;
                          }
                          continue;
                      }
                      if (c == '"')
                      {
                          if (next == '"' && next2 == '"')
                          {
                              in_triple_double = true;
                              col += 2;
                          }
                          else
                          {
                              in_double = true;
                          }
                          continue;
                      }
      
                      if (c == ':')
                      {
                          header_line = li;
                          header_col = static_cast<int>(col);
                          (void)header_col;
                          break;
                      }
                  }
      
                  if (header_line >= 0)
                      break;
              }
      
              if (header_line < 0)
              {
                  throw std::runtime_error(
                      "replace-py-block: opening ':' not found inside marker for file: " +
                      filepath_);
              }
      
              const int nlines =
                  static_cast<int>(lines.size());
              int base_indent =
                  calc_indent(lines[static_cast<std::size_t>(header_line)]);
              int last_body = header_line;
      
              for (int li = header_line + 1; li < nlines; ++li)
              {
                  const std::string &ln =
                      lines[static_cast<std::size_t>(li)];
                  std::size_t pos = first_code_pos(ln);
                  if (pos >= ln.size())
                      continue; // пустая строка в блоке
      
                  int ind = calc_indent(ln);
                  if (ind <= base_indent)
                      break; // вышли из блока по dedent
      
                  last_body = li;
              }
      
              std::size_t region_start =
                  static_cast<std::size_t>(mm.begin);
              std::size_t region_end =
                  static_cast<std::size_t>(last_body);
              if (region_start > region_end ||
                  region_end >= lines.size())
              {
                  throw std::runtime_error(
                      "replace-py-block: internal region calculation error for file: " +
                      filepath_);
              }
      
              std::vector<std::string> adjusted_payload;
              if (indent_from_marker_)
              {
                  std::string prefix =
                      extract_indent_prefix(lines, mm.begin);
                  adjusted_payload =
                      apply_indent_prefix(payload_, prefix, true);
              }
              else
              {
                  adjusted_payload = payload_;
              }
      
              auto it_begin = lines.begin() +
                              static_cast<std::ptrdiff_t>(region_start);
              auto it_end = lines.begin() +
                            static_cast<std::ptrdiff_t>(region_end + 1);
              lines.erase(it_begin, it_end);
              lines.insert(lines.begin() +
                               static_cast<std::ptrdiff_t>(region_start),
                           adjusted_payload.begin(), adjusted_payload.end());
          }
      
      private:
          static int calc_indent(const std::string &line)
          {
              int indent = 0;
              for (char c : line)
              {
                  if (c == ' ')
                      ++indent;
                  else if (c == '\t')
                      indent += 4; // грубая оценка, но достаточно для сравнения
                  else
                      break;
              }
              return indent;
          }
      
          static std::size_t first_code_pos(const std::string &line)
          {
              std::size_t i = 0;
              while (i < line.size() && (line[i] == ' ' || line[i] == '\t'))
                  ++i;
              return i;
          }
      
          bool indent_from_marker_ = true;
          std::vector<std::string> marker_;
          std::vector<std::string> before_;
          std::vector<std::string> after_;
          std::vector<std::string> payload_;
      };
  - op: insert_text_after
    path: src/command_fabric.cpp
    marker: |-
      #include "commands/replace_c_style_block.hpp"
    payload: |-
      #include "commands/replace_py_block.hpp"
  - op: insert_text_after
    path: src/command_fabric.cpp
    marker: |-
          {"replace-c-style-block",
    payload: |-
          {"replace-py-block",
           []() { return std::make_unique<ReplacePyBlockCommand>(); }},
  - op: insert_text_after
    path: src/parser.cpp
    marker: |-
        {"replace-c-style-block", {"replace-c-style-block"}},
    payload: |-
        {"replace-py-block", {"replace-py-block"}},

  - op: append_text
    path: docs/CHUNK_ru.ROBOTS.md
    payload: |-
      
      ### 4.3.7. replace_py_block
      
      Команда для Python, аналогичная `replace_c_style_block`, но вместо фигурных
      скобок использует двоеточие и отступы в стиле Python.
      
      * `marker` должен включать строку, где находится двоеточие, открывающее блок
        (`if ...:`, `for ...:`, `while ...:`, `with ...:`, `def ...:`, `class ...:` и т.д.).
      * Область замены — от начала маркера до конца блока, то есть до первой строки,
        чей отступ **не больше**, чем у строки с двоеточием. Пустые строки внутри
        блока допускаются и не обрывают его.
      * Остальные поля (`payload`, `before`, `after`, `options.indent`) работают так же,
        как у `replace_c_style_block`.
      
      Пример:
      
      ```yaml
      operations:
        - path: src/main.py
          op: replace_py_block
          marker: |-
            if __name__ == "__main__":
          payload: |-
            if __name__ == "__main__":
                print("Hello from CHUNK")
      ```
  - op: append_text
    path: tests/apply.cpp
    payload: |-
      
      TEST_CASE("apply_chunk_main: replace-py-block replaces python block by marker")
      {
          fs::path tmp = fs::temp_directory_path() / "chunk_test_replace_py_block";
          fs::remove_all(tmp);
          fs::create_directories(tmp);
      
          fs::path f = tmp / "main.py";
          {
              std::ofstream out(f);
              out << "# header\n"
                     "if __name__ == \"__main__\":\n"
                     "    print(\"OLD1\")\n"
                     "    print(\"OLD2\")\n"
                     "print(\"AFTER\")\n";
          }
      
          fs::path patch = tmp / "patch.txt";
          {
              std::ofstream out(patch);
              out << "language: python\n"
                     "operations:\n"
                     "  - op: replace_py_block\n"
                     "    path: \"" << f.string() << "\"\n"
                     "    marker: |\n"
                     "      if __name__ == \"__main__\":\n"
                     "    payload: |\n"
                     "      if __name__ == \"__main__\":\n"
                     "        print(\"NEW1\")\n"
                     "        print(\"NEW2\")\n";
          }
      
          int r = run_apply(patch);
          CHECK(r == 0);
      
          auto lines = read_lines(f);
          REQUIRE(lines.size() == 5);
          CHECK(lines[0] == "# header");
          CHECK(lines[1] == "if __name__ == \"__main__\":");
          CHECK(lines[2] == "    print(\"NEW1\")");
          CHECK(lines[3] == "    print(\"NEW2\")");
          CHECK(lines[4] == "print(\"AFTER\")");
      }
